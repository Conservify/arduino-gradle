buildscript {
    repositories {
        mavenCentral()
    }

    dependencies {
        classpath 'net.java.dev.jna:jna:3.4.0' 
        classpath 'net.java.dev.jna:platform:3.4.0' 
    }
}

def getPreferencesCommandLine(buildDir, board) {
    return ["${arduinoHome}/arduino-builder.exe",
             "-dump-prefs",
             "-logger=machine",
             "-hardware",
             "${arduinoHome}/hardware",
             "-hardware",
             "${arduinoPackagesDir}/packages",
             "-tools",
             "${arduinoHome}/tools-builder",
             "-tools",
             "${arduinoHome}/hardware/tools/avr",
             "-tools",
             "${arduinoPackagesDir}/packages",
             "-built-in-libraries",
             "${arduinoHome}/libraries",
             "-libraries",
             "${projectLibrariesDir}",
             "-fqbn=${board}",
             "-ide-version=10609",
             "-build-path",
             "${buildDir}",
             "-warnings=none",
             "-quiet"]
}

def createBuildConfiguration(buildDir, board) {
    def config = new BuildConfiguration()

    config.libraryNames = libraries
    config.projectName = projectName
    config.arduinoHome = arduinoHome
    config.projectDir = projectDir
    config.board = board
    config.originalBuildDir = buildDir

    config.buildDir.mkdirs()

    new ByteArrayOutputStream().withStream { os ->
        def data = exec {
            standardOutput = os
            commandLine = getPreferencesCommandLine(config.buildDir, config.board)
        }

        def friendlyName = config.pathFriendlyBoardName
        def localCopy = new File(buildDir, "arduino.${friendlyName}.prefs")
        localCopy.write(os.toString())

        def preferences = new Properties()
        preferences.load(new StringReader(os.toString().replace("\\", "\\\\")))

        config.preferences = preferences
    }

    return config
}

import groovy.util.logging.Slf4j

@Slf4j
class BuildConfiguration {
    Properties preferences
    String arduinoHome
    String projectName
    String[] libraryNames
    File[] libraryPaths
    File projectDir
    File originalBuildDir
    String board

    String[] getLibrariesSearchPath() {
        return [
            "$arduinoHome/libraries"
        ];
    }

    File getBuildDir() {
        return new File(originalBuildDir, pathFriendlyBoardName)
    }

    void build() {
        def arduinoFiles = []
        gatherSourceFiles(arduinoFiles, new File(buildCorePath))  
        gatherSourceFiles(arduinoFiles, new File(buildVariantPath))  
        libraryPaths.each { path -> 
            gatherSourceFiles(arduinoFiles, path)  
        }

        def sketchFiles = []
        gatherSourceFiles(sketchFiles, projectDir)

        def sketchObjectFiles = sketchFiles.collect { buildFile(it) }
        def arduinoObjectFiles = arduinoFiles.collect { buildFile(it) }

        log.info("Archiving")

        arduinoObjectFiles.each {
            def String archiveCommand = getArCommand(it, "core.a")
            log.debug(archiveCommand)
            execute(archiveCommand)
        }

        log.info("Linking")

        def String linkCommand = getLinkCommand(sketchObjectFiles, "core.a")
        log.debug(linkCommand)
        execute(linkCommand)

        getObjCopyCommands().each {
            log.debug(it)
            execute(it)
        }
    }

    String getBuildCorePath() {
        return this.preferences."build.core.path"
    }

    String getBuildVariantPath() {
        return this.preferences."build.variant.path"
    }

    private String getKey(Properties props, String key) {
        if (props[key] == null) {
            return "{$key}"
        }
        return this.replace(props, props[key])
    }

    private String replace(Properties props, String value) {
        return value.replaceAll(/\{([\w\.-]+)\}/) { all, key ->
            return this.getKey(props, key)
        }
    }

    String getLinkCommand(objectFiles, archiveFile) {
        Properties props = new Properties()
        props["object_files"] = objectFiles.join(" ")
        props["archive_file"] = archiveFile
        props["build.project_name"] = projectName
        props.putAll(this.preferences)
        return getKey(props, "recipe.c.combine.pattern")
    }

    String getCppCommand(source, object) {
        Properties props = new Properties()
        props["source_file"] = source.toString()
        props["object_file"] = object.toString()
        props["includes"] = getIncludes().collect { "-I" + it } .join(" ")
        props.putAll(this.preferences)
        return getKey(props, "recipe.cpp.o.pattern").replace(" -c", " -x c++ -c")
    }

    String getCCommand(source, object) {
        Properties props = new Properties()
        props["source_file"] = source.toString()
        props["object_file"] = object.toString()
        props["includes"] = getIncludes().collect { "-I" + it } .join(" ")
        props.putAll(this.preferences)
        return getKey(props, "recipe.c.o.pattern")
    }

    String getArCommand(object, archive) {
        Properties props = new Properties()
        props["object_file"] = object.toString()
        props["archive_file"] = archive.toString()
        props.putAll(this.preferences)
        return getKey(props, "recipe.ar.pattern")
    }

    private boolean hasKey(String key) {
        return this.preferences[key] != null
    }

    String[] getObjCopyCommands() {
        Properties props = new Properties()
        props["build.project_name"] = projectName
        props.putAll(this.preferences)

        if (hasKey("recipe.objcopy.bin.pattern")) {
            return [
                getKey(props, "recipe.objcopy.bin.pattern"),
            ]
        }
        return [
            getKey(props, "recipe.objcopy.eep.pattern"),
            getKey(props, "recipe.objcopy.hex.pattern")
        ]
    }

    String[] getIncludes() {
        def paths = [
            buildCorePath,
            buildVariantPath
        ]

        libraryPaths.each { library ->
            paths << library.absolutePath
            library.eachDirRecurse() {
                if (!shouldSkipDirectory(it)) {
                    paths << it.absolutePath
                }
            }
        }

        return paths
    }

    String[] getLibraryPaths() {
        def libraryPaths = []
        libraryNames.each { library -> 
            log.info("Searching for $library...")
            getLibrariesSearchPath().each { librariesDir ->
                log.debug("Checking $librariesDir...")
                def libraryDirectory = new File(librariesDir, library)
                if (libraryDirectory.exists() && libraryDirectory.isDirectory()) {
                    libraryPaths << libraryDirectory
                    log.info("Found $libraryDirectory!")
                    return
                }
            }

            throw new GradleException("Unable to find " + library)
        }
        return libraryPaths;
    }

    private boolean isBossac() {
        return this.preferences."upload.tool" == "bossac"
    }

    private boolean isAvrDude() {
        return this.preferences."upload.tool" == "avrdude"
    }

    String getUploadCommand(String serial) {
        if (this.isBossac()) {
            return getBossacUploadCommand(serial);
        }
        if (this.isAvrDude()) {
            return getAvrDudeUploadCommand(serial);
        }
        throw new GradleException("Unknown upload.tool!")
    }

    private String getBossacUploadCommand(String serial) {
        Properties props = new Properties()
        props.putAll(this.preferences)
        props["cmd"] = getKey(props, "tools.bossac.cmd")
        props["path"] = getKey(props, "tools.bossac.path")
        props["upload.verbose"] = "-i -d"
        props["serial.port.file"] = serial
        props["build.project_name"] = projectName
        return getKey(props, "tools.bossac.upload.pattern")
    }

    private String getAvrDudeUploadCommand(String serial) {
        Properties props = new Properties()
        props.putAll(this.preferences)
        props["path"] = getKey(props, "tools.avrdude.path")
        props["cmd.path"] = getKey(props, "tools.avrdude.cmd.path")
        props["config.path"] = getKey(props, "tools.avrdude.config.path")
        props["upload.verbose"] = ""
        props["upload.verify"] = "-v"
        props["serial.port"] = serial
        props["build.project_name"] = projectName
        return getKey(props, "tools.avrdude.upload.pattern")
    }

    String getPathFriendlyBoardName() {
        return board.replace(":", "-")
    }

    void gatherSourceFiles(list, dir) {
        dir.eachFileMatch(~/.*${File.separator}.c/) {
            list << it
        }

        dir.eachFileMatch(~/.*${File.separator}.cpp/) {
            list << it
        }

        dir.eachFileMatch(~/.*${File.separator}.ino/) {
            list << it
        }

        dir.eachDirRecurse() {
            if (!shouldSkipDirectory(it)) {
                gatherSourceFiles(list, it)
            }
        }
    }

    private boolean shouldSkipDirectory(dir) {
        return dir.absolutePath.contains(File.separator + "examples") ||
               dir.absolutePath.contains(File.separator + ".git") ||
               dir.absolutePath.contains(File.separator + ".svn")
    }

    private File buildFile(file) {
        def objectFile = new File(buildDir, file.name + ".o")

        if (file.lastModified() < objectFile.lastModified()) {
            return objectFile
        }

        log.info("Compiling ${file.name}")

        def boolean isCpp = file.getPath() =~ /.*${File.separator}.cpp/ || file.getPath() =~ /.*${File.separator}.ino/
        def String compileCommand = isCpp ? getCppCommand(file, objectFile) : getCCommand(file, objectFile)

        log.debug(compileCommand)
        execute(compileCommand)

        return objectFile
    }

    private def execute(cmd) {
        def sout = new StringBuffer()
        def serr = new StringBuffer()

        def split = CommandLine.translateCommandLine(cmd)
        def fixed = split.collect { it.replace('"', "\\\"") }

        def outProc = Runtime.runtime.exec(fixed as String[], [] as String[], buildDir)
        def running = true

        def bufferPrinter = { buffer ->
            def lastIndex = 0
            while (running) {
                def length = buffer.length()
                if (length > lastIndex) {
                    print buffer.subSequence(lastIndex, length)
                    lastIndex = length
                }
                Thread.sleep(100)
            }
        }
        Thread.start bufferPrinter.curry(sout)
        Thread.start bufferPrinter.curry(serr)

        outProc.consumeProcessOutput(sout, serr)
        try {
            outProc.waitFor()
        } finally {
            running = false
        }

        if (outProc.exitValue()) {
            throw new GradleException("Command execution failed (Exit code: ${outProc.exitValue()})\n${sout.toString()}\n${serr.toString()}")
        }
    }
}

task build(dependsOn: []) << {
    def builder = createBuildConfiguration(buildDir, defaultBoard)
    builder.build()
}

task buildAll << {
    boards.each {
        def builder = createBuildConfiguration(buildDir, it)
        builder.build()
    }
}

task upload(dependsOn: build) << {
    def uploadCommand = config.getUploadCommand("COM37")
    logger.debug(uploadCommand)
    execute(uploadCommand)
}

task clean << {
    ant.delete(dir: buildDir)
}

class CommandLine {
    static String[] translateCommandLine(String toProcess) {
        if (toProcess == null || toProcess.length() == 0) {
            return new String[0];
        }

        final int normal = 0;
        final int inQuote = 1;
        final int inDoubleQuote = 2;
        int state = normal;
        final StringTokenizer tok = new StringTokenizer(toProcess, "\"\' ", true);
        final ArrayList<String> result = new ArrayList<String>();
        final StringBuilder current = new StringBuilder();
        boolean lastTokenHasBeenQuoted = false;

        while (tok.hasMoreTokens()) {
            String nextTok = tok.nextToken();
            switch (state) {
            case inQuote:
                if ("\'".equals(nextTok)) {
                    lastTokenHasBeenQuoted = true;
                    state = normal;
                } else {
                    current.append(nextTok);
                }
                break;
            case inDoubleQuote:
                if ("\"".equals(nextTok)) {
                    lastTokenHasBeenQuoted = true;
                    state = normal;
                } else {
                    current.append(nextTok);
                }
                break;
            default:
                if ("\'".equals(nextTok)) {
                    state = inQuote;
                } else if ("\"".equals(nextTok)) {
                    state = inDoubleQuote;
                } else if (" ".equals(nextTok)) {
                    if (lastTokenHasBeenQuoted || current.length() != 0) {
                        result.add(current.toString());
                        current.setLength(0);
                    }
                } else {
                    current.append(nextTok);
                }
                lastTokenHasBeenQuoted = false;
                break;
            }
        }
        if (lastTokenHasBeenQuoted || current.length() != 0) {
            result.add(current.toString());
        }
        if (state == inQuote || state == inDoubleQuote) {
            throw new RuntimeException("unbalanced quotes in " + toProcess);
        }
        return result.toArray(new String[result.size()]);
    }
}

// vim: set ft=groovy:
