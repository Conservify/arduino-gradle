buildscript {
    repositories {
        mavenCentral()
    }

    dependencies {
        classpath 'net.java.dev.jna:jna:3.4.0' 
        classpath 'net.java.dev.jna:platform:3.4.0' 
    }
}

def execute(cmd) {
    def sout = new StringBuffer()
    def serr = new StringBuffer()

    def split = CommandLine.translateCommandLine(cmd)
    def fixed = split.collect { it.replace('"', "\\\"") }

    def outProc = Runtime.runtime.exec(fixed as String[], [] as String[], buildDir)
    def running = true

    def bufferPrinter = { buffer ->
        def lastIndex = 0
        while (running) {
            def length = buffer.length()
            if (length > lastIndex) {
                print buffer.subSequence(lastIndex, length)
                lastIndex = length
            }
            Thread.sleep(100)
        }
    }
    Thread.start bufferPrinter.curry(sout)
    Thread.start bufferPrinter.curry(serr)

    outProc.consumeProcessOutput(sout, serr)
    try {
        outProc.waitFor()
    } finally {
        running = false
    }

    if (outProc.exitValue()) {
        throw new GradleException("Command execution failed (Exit code: ${outProc.exitValue()})\n${sout.toString()}\n${serr.toString()}")
    }
}

import groovy.util.logging.Slf4j

@Slf4j
class BuildConfiguration {
    Properties preferences
    String arduinoHome
    String projectName
    String[] libraryNames
    File[] libraryPaths
    String board

    String[] getLibrariesSearchPath() {
        return [
            "$arduinoHome/libraries"
        ];
    }

    String getBuildCorePath() {
        return this.preferences."build.core.path"
    }

    String getBuildVariantPath() {
        return this.preferences."build.variant.path"
    }

    private String getKey(Properties props, String key) {
        if (props[key] == null) {
            return "{$key}"
        }
        return this.replace(props, props[key])
    }

    private String replace(Properties props, String value) {
        return value.replaceAll(/\{([\w\.-]+)\}/) { all, key ->
            return this.getKey(props, key)
        }
    }

    String getLinkCommand(objectFiles, archiveFile) {
        Properties props = new Properties()
        props["object_files"] = objectFiles.join(" ")
        props["archive_file"] = archiveFile
        props["build.project_name"] = projectName
        props.putAll(this.preferences)
        return getKey(props, "recipe.c.combine.pattern")
    }

    String getCppCommand(source, object) {
        Properties props = new Properties()
        props["source_file"] = source.toString()
        props["object_file"] = object.toString()
        props["includes"] = getIncludes().collect { "-I" + it } .join(" ")
        props.putAll(this.preferences)
        return getKey(props, "recipe.cpp.o.pattern").replace(" -c", " -x c++ -c")
    }

    String getCCommand(source, object) {
        Properties props = new Properties()
        props["source_file"] = source.toString()
        props["object_file"] = object.toString()
        props["includes"] = getIncludes().collect { "-I" + it } .join(" ")
        props.putAll(this.preferences)
        return getKey(props, "recipe.c.o.pattern")
    }

    String getArCommand(object, archive) {
        Properties props = new Properties()
        props["object_file"] = object.toString()
        props["archive_file"] = archive.toString()
        props.putAll(this.preferences)
        return getKey(props, "recipe.ar.pattern")
    }

    String[] getObjCopyCommands() {
        Properties props = new Properties()
        props["build.project_name"] = projectName
        props.putAll(this.preferences)

        if (getKey(props, "recipe.objcopy.bin.pattern")) {
            return [
                getKey(props, "recipe.objcopy.bin.pattern"),
            ]
        }
        return [
            getKey(props, "recipe.objcopy.eep.pattern"),
            getKey(props, "recipe.objcopy.hex.pattern")
        ]
    }

    String[] getIncludes() {
        def paths = [
            buildCorePath,
            buildVariantPath
        ]

        libraryPaths.each { library ->
            paths << library.absolutePath
            library.eachDirRecurse() {
                if (!shouldSkipDirectory(it)) {
                    paths << it.absolutePath
                }
            }
        }

        return paths
    }

    String[] getLibraryPaths() {
        def libraryPaths = []
        libraryNames.each { library -> 
            log.info("Searching for $library...")
            getLibrariesSearchPath().each { librariesDir ->
                log.debug("Checking $librariesDir...")
                def libraryDirectory = new File(librariesDir, library)
                if (libraryDirectory.exists() && libraryDirectory.isDirectory()) {
                    libraryPaths << libraryDirectory
                    log.info("Found $libraryDirectory!")
                    return
                }
            }

            // println "Unable to find " + library
        }
        return libraryPaths;
    }

    void gatherSourceFiles(list, dir) {
        dir.eachFileMatch(~/.*${File.separator}.c/) {
            list << it
        }

        dir.eachFileMatch(~/.*${File.separator}.cpp/) {
            list << it
        }

        dir.eachFileMatch(~/.*${File.separator}.ino/) {
            list << it
        }

        dir.eachDirRecurse() {
            if (!shouldSkipDirectory(it)) {
                gatherSourceFiles(list, it)
            }
        }
    }

    private boolean shouldSkipDirectory(dir) {
        return dir.absolutePath.contains(File.separator + "examples") ||
               dir.absolutePath.contains(File.separator + ".git") ||
               dir.absolutePath.contains(File.separator + ".svn")
    }
}

def getPreferencesCommandLine(board) {
    return ["${arduinoHome}/arduino-builder.exe",
             "-dump-prefs",
             "-logger=machine",
             "-hardware",
             "${arduinoHome}/hardware",
             "-hardware",
             "${arduinoPackagesDir}/packages",
             "-tools",
             "${arduinoHome}/tools-builder",
             "-tools",
             "${arduinoHome}/hardware/tools/avr",
             "-tools",
             "${arduinoPackagesDir}/packages",
             "-built-in-libraries",
             "${arduinoHome}/libraries",
             "-libraries",
             "${projectLibrariesDir}",
             "-fqbn=${board}",
             "-ide-version=10609",
             "-build-path",
             "${buildDir}",
             "-warnings=none",
             "-quiet"]
}

task prepareBuild {
    doLast {
        buildDir.mkdirs()
    }
}

ext.config = new BuildConfiguration()

task configure(dependsOn:[prepareBuild]) {
    doLast {
        config.libraryNames = libraries
        config.projectName = projectName
        config.arduinoHome = arduinoHome
        config.board = defaultBoard

        new ByteArrayOutputStream().withStream { os ->
            def data = exec {
                standardOutput = os
                commandLine = getPreferencesCommandLine(config.board)
            }

            def friendlyName = config.board.replace(":", "-")
            def localCopy = new File(buildDir, "arduino.${friendlyName}.prefs")
            localCopy.write(os.toString())

            def preferences = new Properties()
            preferences.load(new StringReader(os.toString().replace("\\", "\\\\")))

            config.preferences = preferences
        }
    }
}

def build_file(file) {
    def objectFile = new File(buildDir, file.name + ".o")

    if (file.lastModified() < objectFile.lastModified()) {
        return objectFile
    }

    logger.info("Compiling ${file.name}")

    def boolean isCpp = file.getPath() =~ /.*${File.separator}.cpp/ || file.getPath() =~ /.*${File.separator}.ino/
    def String compileCommand = isCpp ? config.getCppCommand(file, objectFile) : config.getCCommand(file, objectFile)

    logger.debug(compileCommand)
    execute(compileCommand)

    return objectFile
}

task build(dependsOn: [configure]) << {
    def arduinoFiles = []
    config.gatherSourceFiles(arduinoFiles, new File(config.buildCorePath))  
    config.gatherSourceFiles(arduinoFiles, new File(config.buildVariantPath))  
    config.libraryPaths.each { path -> 
        config.gatherSourceFiles(arduinoFiles, path)  
    }

    def sketchFiles = []
    config.gatherSourceFiles(sketchFiles, projectDir)

    def sketchObjectFiles = sketchFiles.collect { build_file(it) }
    def arduinoObjectFiles = arduinoFiles.collect { build_file(it) }

    logger.info("Archiving")

    arduinoObjectFiles.each {
        def String archiveCommand = config.getArCommand(it, "core.a")
        logger.debug(archiveCommand)
        execute(archiveCommand)
    }

    logger.info("Linking")

    def String linkCommand = config.getLinkCommand(sketchObjectFiles, "core.a")
    logger.debug(linkCommand)
    execute(linkCommand)

    config.getObjCopyCommands().each {
        logger.debug(it)
        execute(it)
    }
}

task upload(dependsOn: build) << {
    def cmd = ["$arduinoHome/hardware/tools/avrdude",
        "-C$arduinoHome/hardware/tools/avrdude.conf",
        "-v",
        "-p$cpuName",
        "-carduino",
        "-P$arduinoComPort",
        "-b115200",
        "-D",
        "-Uflash:w:$buildDir/${entry}.hex:i"]
    execute(cmd)
}

task clean << {
    ant.delete(dir: buildDir)
}

class CommandLine {
    static String[] translateCommandLine(String toProcess) {
        if (toProcess == null || toProcess.length() == 0) {
            return new String[0];
        }

        final int normal = 0;
        final int inQuote = 1;
        final int inDoubleQuote = 2;
        int state = normal;
        final StringTokenizer tok = new StringTokenizer(toProcess, "\"\' ", true);
        final ArrayList<String> result = new ArrayList<String>();
        final StringBuilder current = new StringBuilder();
        boolean lastTokenHasBeenQuoted = false;

        while (tok.hasMoreTokens()) {
            String nextTok = tok.nextToken();
            switch (state) {
            case inQuote:
                if ("\'".equals(nextTok)) {
                    lastTokenHasBeenQuoted = true;
                    state = normal;
                } else {
                    current.append(nextTok);
                }
                break;
            case inDoubleQuote:
                if ("\"".equals(nextTok)) {
                    lastTokenHasBeenQuoted = true;
                    state = normal;
                } else {
                    current.append(nextTok);
                }
                break;
            default:
                if ("\'".equals(nextTok)) {
                    state = inQuote;
                } else if ("\"".equals(nextTok)) {
                    state = inDoubleQuote;
                } else if (" ".equals(nextTok)) {
                    if (lastTokenHasBeenQuoted || current.length() != 0) {
                        result.add(current.toString());
                        current.setLength(0);
                    }
                } else {
                    current.append(nextTok);
                }
                lastTokenHasBeenQuoted = false;
                break;
            }
        }
        if (lastTokenHasBeenQuoted || current.length() != 0) {
            result.add(current.toString());
        }
        if (state == inQuote || state == inDoubleQuote) {
            throw new RuntimeException("unbalanced quotes in " + toProcess);
        }
        return result.toArray(new String[result.size()]);
    }
}

// vim: set ft=groovy:
